# -*- coding: utf-8 -*-
"""Sudoku Matplots.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19mOZeVIZh_qocsGkKsqn6TfTH5IFHSJs

# **matplot Graphs for Sudoku Solving Algorithms**

Number of Backtracks

[1] Serial Recursive Backtracking

[2] Parallel Recursive Backtracking (cpu)

[3] Parallel Recursive Bactracking (gpu)

[4] Backtracking steps Comparison of serial recursive backtracking, parallel recursive backtracking on cpu and constraint propagation on cpu

[5] Execution time Comparison of serial recursive backtracking, parallel recursive backtracking on cpu and constraint propagation on cpu

[6] Comparison of Execution Time Across Parallel Recursive Backtracking Algorithms cpu v gpu

[7] Comparison of Execution Time Across Constraint Propagation Algorithms cpu v gpu
"""

import matplotlib.pyplot as plt

# Data for the chart
difficulties = ['Easy', 'Medium', 'Hard', 'Evil']
serial_backtracking_steps = [121, 17281, 10364, 8366]

# Custom shades of blue
colors = ['#cce7ff', '#99d0ff', '#66b8ff', '#339fff']  # Lighter to darker blue gradient

# Create the bar chart
plt.figure(figsize=(8, 5))
bars = plt.bar(difficulties, serial_backtracking_steps, color=colors)
plt.xlabel('Puzzle Difficulty')
plt.ylabel('Backtracking Steps')
plt.title('Serial Recursive Backtracking Steps by Puzzle Difficulty')
plt.ylim(0, 18000)

# Add exact values on top of the bars
for i, v in enumerate(serial_backtracking_steps):
    plt.text(i, v + 100, str(v), ha='center', fontsize=10, color='black')

# Display the chart
plt.show()

import matplotlib.pyplot as plt

# Data for the chart
difficulties = ['Easy', 'Medium', 'Hard', 'Evil']
parallel_backtracking_steps = [76, 1212, 1721, 6291]

# Custom shades of blue
colors = ['#cce7ff', '#99d0ff', '#66b8ff', '#339fff']  # Lighter to darker blue gradient

# Create the bar chart
plt.figure(figsize=(8, 5))
bars = plt.bar(difficulties, parallel_backtracking_steps, color=colors)
plt.xlabel('Puzzle Difficulty')
plt.ylabel('Backtracking Steps')
plt.title('CPU Parallel Recursive Backtracking Steps by Puzzle Difficulty')
plt.ylim(0, 18000)

# Add exact values on top of the bars
for i, v in enumerate(parallel_backtracking_steps):
    plt.text(i, v + 100, str(v), ha='center', fontsize=10, color='black')

# Display the chart
plt.show()

import matplotlib.pyplot as plt

# Data for the chart
difficulties = ['Easy', 'Medium', 'Hard', 'Evil']
gpu_parallel_backtracking_steps = [96, 493, 2322, 10039]

# Custom shades of blue
colors = ['#cce7ff', '#99d0ff', '#66b8ff', '#339fff']  # Lighter to darker blue gradient

# Create the bar chart
plt.figure(figsize=(8, 5))
bars = plt.bar(difficulties, gpu_parallel_backtracking_steps, color=colors)
plt.xlabel('Puzzle Difficulty')
plt.ylabel('Backtracking Steps')
plt.title('GPU Parallel Recursive Backtracking Steps by Puzzle Difficulty')
plt.ylim(0, 18000)

# Add exact values on top of the bars
for i, v in enumerate(gpu_parallel_backtracking_steps):
    plt.text(i, v + 100, str(v), ha='center', fontsize=10, color='black')

# Display the chart
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Data
problem_indices = ['easy', 'medium', 'hard', 'evil']  # Representing the problem instances
serial_backtracking_steps = [121, 17281, 10364, 8366]
parallel_backtracking_steps = [76, 1212, 1721, 6291]
CP_backtracking_steps = [0, 3, 0, 4]

# Avoid zeros for log scale by adding a small offset
CP_backtracking_steps = [step + 0.1 for step in CP_backtracking_steps]

# Plot
plt.figure(figsize=(10, 6))
plt.plot(problem_indices, serial_backtracking_steps, label='Serial Backtracking', marker='o')
plt.plot(problem_indices, parallel_backtracking_steps, label='Parallel Backtracking', marker='s')
plt.plot(problem_indices, CP_backtracking_steps, label='Constraint Propagation', marker='^')

# Apply logarithmic scale
plt.yscale('log')

# Labels, title, and legend
plt.xlabel('Problem Instance', fontsize=12)
plt.ylabel('Number of Backtracking Steps (log scale)', fontsize=12)
plt.title('Comparison of Backtracking Steps Across Algorithms', fontsize=14)
plt.legend(title='Algorithms', fontsize=10)

# Add grid for better readability
plt.grid(which='both', linestyle='--', linewidth=0.5)

# Save and display
plt.tight_layout()
plt.savefig('backtracking_steps_comparison.png', dpi=300)
plt.show()

import matplotlib.pyplot as plt

# Data
problem_labels = ['Easy', 'Medium', 'Hard', 'Evil']  # Problem instance labels
serial_time = [0.0076, 0.7482, 0.4437, 0.3354]
parallel_time = [0.0112, 1.1966, 0.4630, 0.3063]
CP_time = [0.0044, 0.0184, 0.0064, 0.0542]

# Plot
plt.figure(figsize=(10, 6))
plt.plot(problem_labels, serial_time, label='Serial Execution Time', marker='o', color='blue')
plt.plot(problem_labels, parallel_time, label='Parallel Execution Time', marker='s', color='orange')
plt.plot(problem_labels, CP_time, label='Constraint Propagation Time', marker='^', color='green')

# Labels, title, and legend
plt.xlabel('Problem Instance', fontsize=12)
plt.ylabel('Execution Time (seconds)', fontsize=12)
plt.title('Comparison of Execution Time Across Algorithms', fontsize=14)
plt.legend(title='Algorithms', fontsize=10)

# Add grid for better readability
plt.grid(which='both', linestyle='--', linewidth=0.5)

# Adjust y-axis range for better visibility
plt.ylim(bottom=0, top=max(parallel_time) * 1.5)

# Annotate small values for clarity
for i, steps in enumerate(serial_time):
    plt.text(i, steps + 0.05, f'{steps:.4f}', ha='center', fontsize=9, color='blue')
for i, steps in enumerate(parallel_time):
    plt.text(i, steps + 0.08, f'{steps:.4f}', ha='center', fontsize=9, color='orange')
for i, steps in enumerate(CP_time):
    plt.text(i, steps + 0.02, f'{steps:.4f}', ha='center', fontsize=9, color='green')

# Save and display
plt.tight_layout()
plt.savefig('execution_time_comparison_fixed.png', dpi=300)
plt.show()

import matplotlib.pyplot as plt

# Data
problem_labels = ['Easy', 'Medium', 'Hard', 'Evil']  # Problem instance labels
CPU_time = [0.0112, 1.1966, 0.4630, 0.3063]
GPU_time = [2.9128, 29.9128,316.8682,491.8598]

# Plot
plt.figure(figsize=(10, 6))
plt.plot(problem_labels, CPU_time, label='CPU Parallel Recursive Backtracking', marker='s')
plt.plot(problem_labels, GPU_time, label='GPU Parallel Recursive Backtracking', marker='^')

# Labels, title, and legend
plt.xlabel('Problem Instance', fontsize=12)
plt.ylabel('Execution Time (seconds)', fontsize=12)
plt.title('Comparison of Execution Time Across Parallel Recursive Backtracking Algorithms', fontsize=14)
plt.legend(title='Algorithms', fontsize=10)

# Add grid for better readability
plt.grid(which='both', linestyle='--', linewidth=0.5)

# Adjust y-axis range for better visibility
# plt.ylim(bottom=0, top=max(CPU_time) * 1.1)

# Annotate small values for clarity
for i, steps in enumerate(CPU_time):
    plt.text(i, steps + 0.01, f'{steps:.4f}', fontsize=9, color='blue')
for i, steps in enumerate(GPU_time):
    plt.text(i, steps + 0.01, f'{steps:.4f}', ha='center', fontsize=9, color='orange')

# Save and display
plt.tight_layout()
plt.savefig('execution_time_comparison_labels.png', dpi=300)
plt.show()

import matplotlib.pyplot as plt

# Data
problem_labels = ['Easy', 'Medium', 'Hard', 'Evil']  # Problem instance labels
GPU_time = [0.1256, 0.9903, 0.3949, 2.7790]
CPU_time = [0.0044, 0.0184, 0.0064, 0.0542]

# Plot
plt.figure(figsize=(10, 6))
plt.plot(problem_labels, GPU_time, label='CP GPU  Time', marker='o')
plt.plot(problem_labels, CPU_time, label='CP CPU Time', marker='^')

# Labels, title, and legend
plt.xlabel('Problem Instance', fontsize=12)
plt.ylabel('Execution Time (seconds)', fontsize=12)
plt.title('Comparison of Execution Time Across Constraint Propagation Algorithms', fontsize=14)
plt.legend(title='Algorithms', fontsize=10)

# Add grid for better readability
plt.grid(which='both', linestyle='--', linewidth=0.5)


# Annotate small values for clarity
for i, steps in enumerate(CPU_time):
    plt.text(i, steps + 0.01, f'{steps:.4f}', ha='center', fontsize=9, color='red')

# Save and display
plt.tight_layout()
plt.savefig('execution_time_comparison_labels.png', dpi=300)
plt.show()